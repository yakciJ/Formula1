import { parseLosslessNumber } from './numberParsers.js';
import { revive } from './revive.js';

/**
 * The LosslessJSON.parse() method parses a string as JSON, optionally transforming
 * the value produced by parsing.
 *
 * The parser is based on the parser of Tan Li Hou shared in
 * https://lihautan.com/json-parser-with-javascript/
 *
 * @param text
 * The string to parse as JSON. See the JSON object for a description of JSON syntax.
 *
 * @param [reviver]
 * If a function, prescribes how the value originally produced by parsing is
 * transformed, before being returned.
 *
 * @param [parseNumber=parseLosslessNumber]
 * Pass a custom number parser. Input is a string, and the output can be unknown
 * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.
 *
 * @returns Returns the Object corresponding to the given JSON text.
 *
 * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.
 */
export function parse(text, reviver) {
  var parseNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : parseLosslessNumber;
  var i = 0;
  var value = parseValue();
  expectValue(value);
  expectEndOfInput();
  return reviver ? revive(value, reviver) : value;

  function parseObject() {
    if (text[i] === '{') {
      i++;
      skipWhitespace();
      var object = {};
      var initial = true;

      while (i < text.length && text[i] !== '}') {
        if (!initial) {
          eatComma();
          skipWhitespace();
        } else {
          initial = false;
        }

        var key = parseString();

        if (key === undefined) {
          throwObjectKeyExpected();
        }

        if (typeof object[key] !== 'undefined') {
          // Note that we could also test `if(key in object) {...}`
          // or `if (object[key] !== 'undefined') {...}`, but that is slower.
          throwDuplicateKey(key);
        }

        skipWhitespace();
        eatColon();
        object[key] = parseValue();
      }

      if (text[i] !== '}') {
        throwObjectKeyOrEndExpected();
      }

      i++;
      return object;
    }
  }

  function parseArray() {
    if (text[i] === '[') {
      i++;
      skipWhitespace();
      var array = [];
      var initial = true;

      while (i < text.length && text[i] !== ']') {
        if (!initial) {
          eatComma();
        } else {
          initial = false;
        }

        var _value = parseValue();

        expectArrayItem(_value);
        array.push(_value);
      }

      if (text[i] !== ']') {
        throwArrayItemOrEndExpected();
      }

      i++;
      return array;
    }
  }

  function parseValue() {
    var _ref, _ref2, _ref3, _ref4, _ref5, _parseString;

    skipWhitespace();
    var value = (_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_parseString = parseString()) !== null && _parseString !== void 0 ? _parseString : parseNumeric()) !== null && _ref5 !== void 0 ? _ref5 : parseObject()) !== null && _ref4 !== void 0 ? _ref4 : parseArray()) !== null && _ref3 !== void 0 ? _ref3 : parseKeyword('true', true)) !== null && _ref2 !== void 0 ? _ref2 : parseKeyword('false', false)) !== null && _ref !== void 0 ? _ref : parseKeyword('null', null);
    skipWhitespace();
    return value;
  }

  function parseKeyword(name, value) {
    if (text.slice(i, i + name.length) === name) {
      i += name.length;
      return value;
    }
  }

  function skipWhitespace() {
    while (isWhitespace(text[i])) {
      i++;
    }
  }

  function parseString() {
    if (text[i] === '"') {
      i++;
      var result = '';

      while (i < text.length && text[i] !== '"') {
        if (text[i] === '\\') {
          var char = text[i + 1];
          var escapeChar = escapeCharacters[char];

          if (escapeChar !== undefined) {
            result += escapeChar;
            i++;
          } else if (char === 'u') {
            if (isHex(text[i + 2]) && isHex(text[i + 3]) && isHex(text[i + 4]) && isHex(text[i + 5])) {
              result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16));
              i += 5;
            } else {
              throwInvalidUnicodeCharacter(i);
            }
          } else {
            throwInvalidEscapeCharacter(i);
          }
        } else {
          result += text[i];
        }

        i++;
      }

      expectEndOfString();
      i++;
      return result;
    }
  }

  function parseNumeric() {
    var start = i;

    if (text[i] === '-') {
      i++;
      expectDigit(start);
    }

    if (text[i] === '0') {
      i++;
    } else if (isNonZeroDigit(text[i])) {
      i++;

      while (isDigit(text[i])) {
        i++;
      }
    }

    if (text[i] === '.') {
      i++;
      expectDigit(start);

      while (isDigit(text[i])) {
        i++;
      }
    }

    if (text[i] === 'e' || text[i] === 'E') {
      i++;

      if (text[i] === '-' || text[i] === '+') {
        i++;
      }

      expectDigit(start);

      while (isDigit(text[i])) {
        i++;
      }
    }

    if (i > start) {
      return parseNumber(text.slice(start, i));
    }
  }

  function eatComma() {
    if (text[i] !== ',') {
      throw new SyntaxError("Comma ',' expected after value ".concat(gotAt()));
    }

    i++;
  }

  function eatColon() {
    if (text[i] !== ':') {
      throw new SyntaxError("Colon ':' expected after property name ".concat(gotAt()));
    }

    i++;
  }

  function expectValue(value) {
    if (value === undefined) {
      throw new SyntaxError("JSON value expected ".concat(gotAt()));
    }
  }

  function expectArrayItem(value) {
    if (value === undefined) {
      throw new SyntaxError("Array item expected ".concat(gotAt()));
    }
  }

  function expectEndOfInput() {
    if (i < text.length) {
      throw new SyntaxError("Expected end of input ".concat(gotAt()));
    }
  }

  function expectDigit(start) {
    if (!isDigit(text[i])) {
      var numSoFar = text.slice(start, i);
      throw new SyntaxError("Invalid number '".concat(numSoFar, "', expecting a digit ").concat(gotAt()));
    }
  }

  function expectEndOfString() {
    if (text[i] !== '"') {
      throw new SyntaxError("End of string '\"' expected ".concat(gotAt()));
    }
  }

  function throwObjectKeyExpected() {
    throw new SyntaxError("Quoted object key expected ".concat(gotAt()));
  }

  function throwDuplicateKey(key) {
    throw new SyntaxError("Duplicate key '".concat(key, "' encountered at position ").concat(i - key.length - 1));
  }

  function throwObjectKeyOrEndExpected() {
    throw new SyntaxError("Quoted object key or end of object '}' expected ".concat(gotAt()));
  }

  function throwArrayItemOrEndExpected() {
    throw new SyntaxError("Array item or end of array ']' expected ".concat(gotAt()));
  }

  function throwInvalidEscapeCharacter(start) {
    var chars = text.slice(start, start + 2);
    throw new SyntaxError("Invalid escape character '".concat(chars, "' ").concat(pos()));
  }

  function throwInvalidUnicodeCharacter(start) {
    var end = start + 2;

    while (/\w/.test(text[end])) {
      end++;
    }

    var chars = text.slice(start, end);
    throw new SyntaxError("Invalid unicode character '".concat(chars, "' ").concat(pos()));
  } // zero based character position


  function pos() {
    return "at position ".concat(i);
  }

  function got() {
    return text[i] ? "but got '".concat(text[i], "'") : 'but reached end of input';
  }

  function gotAt() {
    return got() + ' ' + pos();
  }
}

function isWhitespace(char) {
  return whitespaceCharacters[char] === true;
}

function isHex(char) {
  return /^[0-9a-fA-F]/.test(char);
}

function isDigit(char) {
  return /[0-9]/.test(char);
}

function isNonZeroDigit(char) {
  return /[1-9]/.test(char);
} // map with all escape characters


var escapeCharacters = {
  '"': '"',
  '\\': '\\',
  '/': '/',
  b: '\b',
  f: '\f',
  n: '\n',
  r: '\r',
  t: '\t' // note that \u is handled separately in parseString()

}; // map with all whitespace characters

var whitespaceCharacters = {
  ' ': true,
  '\n': true,
  '\t': true,
  '\r': true
};
//# sourceMappingURL=parse.js.map